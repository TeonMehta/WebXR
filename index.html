<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Lesson 1</title>
		<style>
			canvas {
				width: 100vw;
				height: 100vh;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>

		<script id="vertex-data" type="not-javascript"></script>
		    
		<script id="fragment-data" type="not-javascript"></script>

		<script id="vertex-source" type="not-javascript">
			        attribute vec4 vertex_points;
			        void main() {
			            gl_Position = vertex_points;
			        }
			    
		</script>
		<script id="fragment-source" type="not-javascript">
			        precision mediump float;
			        void main() {
			            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
			        }
		</script>

		<script type="text/javascript">
			const canvas = document.querySelector("#canvas");
			const gl = canvas.getContext("webgl");

			if (!gl) {
				console.log("WebGL unavailable");
			} else {
				console.log("WebGL is good to go");
			}

			// DEFine rhe points in the scene
			const coordinates = [-0.7, 0.7, -0.7, 0, 0.7, 0, 0.7, 0];
			// create an empty buffer object to store the vertex points
			const pointsBuffer = gl.createBuffer();
			// connect the empty buffer objext to the gl context
			gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);

			// Load the vertices into the GL's connected buffer
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(coordinates),
				gl.STATIC_DRAW
			);

			// Locate the attribute from the vertex shader source in the program
			const pointsAttributeLocation = gl.getAttribLocation(
				program,
				"vertex_points"
			);

			// Connect the attribute to the points data currently in the buffer object
			gl.vertexAttribPointer(pointsAttributeLocation, 2, gl.FLOAT, false, 0, 0);

			let size = 2; // components per iteration (2 because just x,y points)
			let type = gl.FLOAT; // data is 32bit floats
			let normalize = false;
			let stride = 0; // don't skip indices between coordinate pairs
			let offset = 0; // start at beginning of buffer
			gl.vertexAttribPointer(
				positionAttributeLocation,
				size,
				type,
				normalize,
				stride,
				offset
			); 
            // Send the points data to the GPU
			gl.enableVertexAttribArray(pointsAttributeLocation);

            

			// Create a variable to store the data for our vertex shader
			const vsSource = document.querySelector("#vertex-data").text; // Create a  variable to store the data from our fragment shader
			const fsSource = document.querySelector("#fragment-data").text;

			// Compile the shaders into GLSL
			const vertexShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertexShader, vsSource);
			gl.compileShader(vertexShader);
			const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragmentShader, fsSource);
			gl.compileShader(fragmentShader);

			// Create a carry-out container that will pass the shader functions to the GPU
			const program = gl.createProgram();
			// Attach the shaders
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			// Link the shaders
			gl.linkProgram(program);
		</script>
	</body>
</html>
